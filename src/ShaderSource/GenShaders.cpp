/**************************************/
/*        Shaders sources file        */
/* Generated with genShaderSource.php */
/**************************************/

#include <gle/opengl.h>
#include <ShaderSource.hpp>

const char* gle::ShaderSource::VertexShader = 
"#version 330 core \n"
"\n"
"#define GLE_IN_VERTEX_POSITION_LOCATION 0 \n"
"#define GLE_IN_VERTEX_NORMAL_LOCATION 1 \n"
"\n"
"#define GLE_IN_VERTEX_TEXTURE_COORD_LOCATION 2 \n"
"\n"
"#define GLE_LIGHT_ENABLED 1\n"
"#define NB_DIRECTIONAL_LIGHTS %nb_directional_lights \n"
"#define NB_POINT_LIGHTS %nb_point_lights  \n"
"\n"
"uniform mat4 gle_PMatrix; \n"
"uniform float gle_fogDensity;\n"
"#if NB_DIRECTIONAL_LIGHTS > 0\n"
"	uniform vec3 gle_directionalLightDirection[NB_DIRECTIONAL_LIGHTS];\n"
"	uniform vec3 gle_directionalLightColor[NB_DIRECTIONAL_LIGHTS];\n"
"#endif\n"
"#if NB_POINT_LIGHTS > 0\n"
"	uniform vec3 gle_pointLightPosition[NB_POINT_LIGHTS];\n"
"	uniform vec3 gle_pointLightAttenuation[NB_POINT_LIGHTS];\n"
"#endif\n"
"\n"
"uniform mat4 gle_MVMatrix; \n"
"#if NB_DIRECTIONAL_LIGHTS > 0 || NB_POINT_LIGHTS > 0\n"
"	uniform mat3 gle_NMatrix;\n"
"#endif\n"
"\n"
"layout(std140) uniform materialBlock\n"
"{\n"
"	uniform vec4 gle_ambientColor;\n"
"	uniform vec4 gle_diffuseColor;\n"
"	uniform vec4 gle_specularColor;\n"
"	uniform float gle_shininess;\n"
"	uniform float gle_specularIntensity;\n"
"	uniform float gle_diffuseIntensity;\n"
"};\n"
"\n"
"layout (location = GLE_IN_VERTEX_POSITION_LOCATION) in vec3 gle_vPosition; \n"
"layout (location = GLE_IN_VERTEX_NORMAL_LOCATION) in vec3 gle_vNormal; \n"
"layout (location = GLE_IN_VERTEX_TEXTURE_COORD_LOCATION) in vec2 gle_vTextureCoord;\n"
"\n"
"out float gle_varying_fogFactor; \n"
"out vec3 gle_varying_vLightWeighting; \n"
"out vec2 gle_varying_vTextureCoord;\n"
"#if NB_POINT_LIGHTS > 0\n"
"	out vec3 gle_varying_normal;\n"
"	out vec3 gle_varying_eyeDirection;\n"
"	out vec3 gle_varying_pointLightDirection[NB_POINT_LIGHTS];\n"
"	out float gle_varying_pointLightAttenuation[NB_POINT_LIGHTS];\n"
"#endif\n"
"\n"
"void main(void) { \n"
"	vec4 gle_mvPosition = gle_MVMatrix * vec4(gle_vPosition, 1.0);\n"
"	gl_Position = gle_PMatrix * gle_mvPosition; \n"
"	float fogDistance = length(gle_mvPosition); \n"
"	const float LOG2 = 1.442695; \n"
"	gle_varying_fogFactor = exp2(-gle_fogDensity * gle_fogDensity * fogDistance * fogDistance * LOG2); \n"
"	gle_varying_fogFactor = clamp(gle_varying_fogFactor, 0.0, 1.0); \n"
"	#if NB_DIRECTIONAL_LIGHTS > 0 || NB_POINT_LIGHTS > 0\n"
"		vec3 transformedNormal = normalize(gle_NMatrix * gle_vNormal);\n"
"	#endif\n"
"	gle_varying_vTextureCoord = gle_vTextureCoord; \n"
"\n"
"	gle_varying_vLightWeighting = vec3(0.0, 0.0, 0.0);\n"
"\n"
"	#if NB_DIRECTIONAL_LIGHTS > 0\n"
"		for (int i = 0; i < NB_DIRECTIONAL_LIGHTS; ++i)\n"
"		{\n"
"			float directionalLightWeighting = max(dot(transformedNormal, gle_directionalLightDirection[i]), 0.0);\n"
"			gle_varying_vLightWeighting += gle_directionalLightColor[i] * gle_diffuseColor.rgb * directionalLightWeighting;\n"
"		}\n"
"	#endif\n"
"	#if NB_POINT_LIGHTS > 0\n"
"		gle_varying_normal = transformedNormal;\n"
"		gle_varying_eyeDirection = -gle_mvPosition.xyz;\n"
"		for (int i = 0; i < NB_POINT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 pointLightDirection = gle_pointLightPosition[i] - gle_mvPosition.xyz;\n"
"			float d = length(pointLightDirection);\n"
"			if (gle_pointLightAttenuation[i].x == 0.0 && gle_pointLightAttenuation[i].y == 0.0 && gle_pointLightAttenuation[i].z == 0.0)\n"
"			   gle_varying_pointLightAttenuation[i] = 1.0;\n"
"			else\n"
"			   gle_varying_pointLightAttenuation[i] = 1.0 / (gle_pointLightAttenuation[i].x +\n"
"			   			      	 (gle_pointLightAttenuation[i].y * d) + \n"
"							 (gle_pointLightAttenuation[i].z * d * d));\n"
"			if (gle_varying_pointLightAttenuation[i] > 1.0)\n"
"				gle_varying_pointLightAttenuation[i] = 1.0;\n"
"			gle_varying_pointLightDirection[i] = pointLightDirection;\n"
"		}\n"
"	#endif\n"
"	\n"
"	gle_varying_vLightWeighting += gle_ambientColor.rgb;\n"
"}\n"
"\n"
;

const char* gle::ShaderSource::FragmentShader = 
"#version 330 core \n"
"  \n"
"#define GLE_OUT_FRAGMENT_COLOR_LOCATION 0 \n"
"#define NB_POINT_LIGHTS %nb_point_lights  \n"
"  \n"
"layout (location = GLE_OUT_FRAGMENT_COLOR_LOCATION) out vec4 gle_FragColor; \n"
"\n"
"layout(std140) uniform materialBlock\n"
"{\n"
"	uniform vec4 gle_ambientColor;\n"
"	uniform vec4 gle_diffuseColor;\n"
"	uniform vec4 gle_specularColor;\n"
"	uniform float gle_shininess;\n"
"	uniform float gle_specularIntensity;\n"
"	uniform float gle_diffuseIntensity;\n"
"};\n"
"\n"
"uniform vec3 gle_fogColor;\n"
"\n"
"uniform sampler2D gle_colorMap;\n"
"uniform bool gle_hasColorMap;\n"
"\n"
"#if NB_POINT_LIGHTS > 0\n"
"	uniform vec3 gle_pointLightColor[NB_POINT_LIGHTS];\n"
"	uniform vec3 gle_pointLightSpecularColor[NB_POINT_LIGHTS];\n"
"#endif\n"
"\n"
"in float gle_varying_fogFactor; \n"
"in vec3 gle_varying_vLightWeighting;\n"
"in float gle_varying_vLightAttenuation;\n"
"in vec2 gle_varying_vTextureCoord;\n"
"#if NB_POINT_LIGHTS > 0\n"
"	in vec3 gle_varying_normal;\n"
"	in vec3 gle_varying_eyeDirection;\n"
"	in vec3 gle_varying_pointLightDirection[NB_POINT_LIGHTS];\n"
"	in float gle_varying_pointLightAttenuation[NB_POINT_LIGHTS];\n"
"#endif\n"
"\n"
"void main(void) { \n"
"	vec3 lightWeighting = gle_varying_vLightWeighting;\n"
"	vec3 N = normalize(gle_varying_normal);\n"
"	vec3 E = normalize(gle_varying_eyeDirection);\n"
"	#if NB_POINT_LIGHTS > 0\n"
"		for (int i = 0; i < NB_POINT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 L = normalize(gle_varying_pointLightDirection[i]);\n"
"			if (gle_diffuseIntensity > 0)\n"
"			{\n"
"				float pointLightWeighting = max(dot(N, L), 0.0);\n"
"				lightWeighting += gle_pointLightColor[i] * gle_diffuseColor.rgb * pointLightWeighting * gle_diffuseIntensity * \n"
"				gle_varying_pointLightAttenuation[i];\n"
"			}\n"
"			if (gle_specularIntensity > 0)\n"
"			{\n"
"				vec3 reflectionDirection = reflect(-L, N);\n"
"				float pointLightSpecularWeighting = pow(max(dot(reflectionDirection, E), 0.0), gle_shininess);\n"
"				lightWeighting += gle_pointLightSpecularColor[i] * gle_specularColor.rgb\n"
"							* pointLightSpecularWeighting * gle_specularIntensity * gle_varying_pointLightAttenuation[i];\n"
"			}\n"
"		}\n"
"	#endif\n"
"\n"
"	vec2 tmp = vec2(gle_varying_vTextureCoord.x, -gle_varying_vTextureCoord.y);\n"
"	if (gle_hasColorMap)\n"
"	{\n"
"		gle_FragColor = texture2D(gle_colorMap, tmp) * vec4(lightWeighting, 1.0);\n"
"	}\n"
"	else\n"
"	{\n"
"		gle_FragColor = vec4(lightWeighting, 1.0);\n"
"	}\n"
"	gle_FragColor = mix(vec4(gle_fogColor, 1.0), gle_FragColor, gle_varying_fogFactor);\n"
"}\n"
"\n"
;

