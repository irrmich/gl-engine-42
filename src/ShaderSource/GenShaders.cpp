/**************************************/
/*        Shaders sources file        */
/* Generated with genShaderSource.php */
/**************************************/

#include <gle/opengl.h>
#include <ShaderSource.hpp>

const char* gle::ShaderSource::VertexShader = 
"#version 330 core \n"
"\n"
"#define GLE_IN_VERTEX_POSITION_LOCATION 0\n"
"#define GLE_IN_VERTEX_NORMAL_LOCATION 1\n"
"#define GLE_IN_VERTEX_TANGENT_LOCATION 2\n"
"#define GLE_IN_VERTEX_TEXTURE_COORD_LOCATION 3\n"
"#define GLE_IN_VERTEX_MESH_ID_LOCATION 4\n"
"\n"
"#define GLE_LIGHT_ENABLED 1\n"
"\n"
"#define GLE_NB_DIRECTIONAL_LIGHTS %nb_directional_lights \n"
"#define GLE_NB_POINT_LIGHTS %nb_point_lights\n"
"#define GLE_NB_SPOT_LIGHTS %nb_spot_lights\n"
"#define GLE_NB_STATIC_MESHES %nb_static_meshes\n"
"#define GLE_NB_MATERIALS %nb_materials\n"
"\n"
"#define GLE_CUBE_MAP 1\n"
"\n"
"uniform float gle_fogDensity;\n"
"\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"	uniform vec3 gle_directionalLightDirection[GLE_NB_DIRECTIONAL_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_POINT_LIGHTS > 0\n"
"	uniform vec3 gle_pointLightPosition[GLE_NB_POINT_LIGHTS];\n"
"	uniform vec3 gle_pointLightAttenuation[GLE_NB_POINT_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_SPOT_LIGHTS > 0\n"
"	uniform vec3 gle_spotLightPosition[GLE_NB_SPOT_LIGHTS];\n"
"	uniform vec3 gle_spotLightAttenuation[GLE_NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"uniform mat4 gle_MWMatrix;\n"
"\n"
"uniform mat4 gle_ViewMatrix;\n"
"uniform mat4 gle_PMatrix;\n"
"\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"	uniform mat3 gle_NMatrix;\n"
"\n"
"#if GLE_NB_STATIC_MESHES > 0\n"
"\n"
"struct gle_StaticMesh {\n"
"	mat4	MWMatrix;\n"
"};\n"
"\n"
"layout(std140) uniform staticMeshesBlock\n"
"{\n"
"	gle_StaticMesh meshes[GLE_NB_STATIC_MESHES];\n"
"} gle_staticMeshes;\n"
"\n"
"#endif\n"
"\n"
"uniform vec3 gle_CameraPos;\n"
"\n"
"\n"
"struct gle_MaterialStruct\n"
"{\n"
"	vec4 ambientColor;\n"
"	vec4 diffuseColor;\n"
"	vec4 specularColor;\n"
"	float shininess;\n"
"	float specularIntensity;\n"
"	float diffuseIntensity;\n"
"	float reflectionIntensity;\n"
"	float envMapType;\n"
"	float hasColorMap;\n"
"	float hasNormalMap;\n"
"};\n"
"\n"
"layout(std140) uniform materialBlock\n"
"{\n"
"	gle_MaterialStruct materials[GLE_NB_MATERIALS];\n"
"} gle_material;\n"
"\n"
"layout (location = GLE_IN_VERTEX_POSITION_LOCATION) in vec3 gle_vPosition; \n"
"layout (location = GLE_IN_VERTEX_NORMAL_LOCATION) in vec3 gle_vNormal;\n"
"layout (location = GLE_IN_VERTEX_TANGENT_LOCATION) in vec3 gle_vTangent; \n"
"layout (location = GLE_IN_VERTEX_TEXTURE_COORD_LOCATION) in vec2 gle_vTextureCoord;\n"
"layout (location = GLE_IN_VERTEX_MESH_ID_LOCATION) in vec3 gle_vMeshIdentifier;\n"
"\n"
"out float gle_varying_fogFactor; \n"
"out vec3 gle_varying_vLightWeighting;\n"
"out vec2 gle_varying_vTextureCoord;\n"
"out vec3 gle_varying_envMapVector;\n"
"flat out vec3 gle_varying_vMeshIdentifier;\n"
"\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"	out vec3 gle_varying_normal;\n"
"	out vec3 gle_varying_eyeDirection;\n"
"#endif\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"	out vec3 gle_varying_directionalLightDirection[GLE_NB_DIRECTIONAL_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_POINT_LIGHTS > 0\n"
"	out vec3 gle_varying_pointLightDirection[GLE_NB_POINT_LIGHTS];\n"
"	out float gle_varying_pointLightAttenuation[GLE_NB_POINT_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_SPOT_LIGHTS > 0\n"
"	out vec3 gle_varying_spotLightDirection[GLE_NB_SPOT_LIGHTS];\n"
"	out vec3 gle_varying_spotLightRealDirection[GLE_NB_SPOT_LIGHTS];\n"
"	out float gle_varying_spotLightAttenuation[GLE_NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"void main(void) {\n"
"\n"
"	vec4 ambientColor = gle_material.materials[int(gle_vMeshIdentifier.z)].ambientColor;\n"
"	vec4 diffuseColor = gle_material.materials[int(gle_vMeshIdentifier.z)].diffuseColor;\n"
"	vec4 specularColor = gle_material.materials[int(gle_vMeshIdentifier.z)].specularColor;\n"
"	float shininess = gle_material.materials[int(gle_vMeshIdentifier.z)].shininess;\n"
"	float specularIntensity = gle_material.materials[int(gle_vMeshIdentifier.z)].specularIntensity;\n"
"	float diffuseIntensity = gle_material.materials[int(gle_vMeshIdentifier.z)].diffuseIntensity;\n"
"	float reflectionIntensity = gle_material.materials[int(gle_vMeshIdentifier.z)].reflectionIntensity;\n"
"	float envMapType = gle_material.materials[int(gle_vMeshIdentifier.z)].envMapType;\n"
"	float hasColorMap = gle_material.materials[int(gle_vMeshIdentifier.z)].hasColorMap;\n"
"	float hasNormalMap = gle_material.materials[int(gle_vMeshIdentifier.z)].hasNormalMap;\n"
"	\n"
"	gle_varying_vMeshIdentifier = gle_vMeshIdentifier;\n"
"\n"
"	mat4 mvMatrix, mwMatrix;\n"
"	#if GLE_NB_STATIC_MESHES > 0\n"
"		if (!bool(gle_vMeshIdentifier.x))\n"
"		{\n"
"			mvMatrix = gle_ViewMatrix * gle_staticMeshes.meshes[int(gle_vMeshIdentifier.y)].MWMatrix;\n"
"			mwMatrix = gle_staticMeshes.meshes[int(gle_vMeshIdentifier.y)].MWMatrix;\n"
"		}\n"
"		else\n"
"	#endif\n"
"		{\n"
"			mvMatrix = gle_ViewMatrix * gle_MWMatrix;\n"
"			mwMatrix = gle_MWMatrix;\n"
"		}\n"
"	vec4 gle_mvPosition = mvMatrix * vec4(gle_vPosition, 1);\n"
"	mat3 nMatrix = transpose(mat3(inverse(mvMatrix)));\n"
"	gl_Position = gle_PMatrix * gle_mvPosition; \n"
"	float fogDistance = length(gle_mvPosition); \n"
"	const float LOG2 = 1.442695;\n"
"	gle_varying_fogFactor = exp2(-gle_fogDensity * gle_fogDensity * fogDistance * fogDistance * LOG2); \n"
"	gle_varying_fogFactor = clamp(gle_varying_fogFactor, 0.0, 1.0); \n"
"	#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"		vec3 transformedNormal = normalize(nMatrix * gle_vNormal);\n"
"	#endif\n"
"	gle_varying_vTextureCoord = gle_vTextureCoord; \n"
"\n"
"	gle_varying_vLightWeighting = vec3(0.0, 0.0, 0.0);\n"
"\n"
"	vec3 n, t, b;\n"
"	#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"		gle_varying_normal = nMatrix * gle_vNormal;\n"
"		if (hasNormalMap > 0.0)\n"
"		{\n"
"			n = transformedNormal;\n"
"			if (gle_vTangent.x != 0.0 && gle_vTangent.y != 0.0 && gle_vTangent.z != 0.0)\n"
"				t = normalize(nMatrix * gle_vTangent);\n"
"			else\n"
"				{\n"
"					vec3 c1 = cross(gle_vNormal, vec3(0.0, 0.0, 1.0)); \n"
"					vec3 c2 = cross(gle_vNormal, vec3(0.0, 1.0, 0.0)); \n"
"					if(length(c1) > length(c2))\n"
"						t = normalize(nMatrix * c1);\n"
"					else\n"
"						t = normalize(nMatrix * c2);\n"
"				}\n"
"			b = cross(n, t);\n"
"			vec3 tmp = -gle_mvPosition.xyz;\n"
"			gle_varying_eyeDirection.x = dot(tmp, t);\n"
"			gle_varying_eyeDirection.y = dot(tmp, b);\n"
"			gle_varying_eyeDirection.z = dot(tmp, n);\n"
"		}	\n"
"		else\n"
"			gle_varying_eyeDirection = -gle_mvPosition.xyz;\n"
"	#endif\n"
"	#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"	for (int i = 0; i < GLE_NB_DIRECTIONAL_LIGHTS; ++i)\n"
"	{\n"
"		vec3 directionalLightDirection = normalize(mat3(mvMatrix) * gle_directionalLightDirection[i]);\n"
"		if (hasNormalMap > 0.0)\n"
"			{\n"
"				vec3 tmp = directionalLightDirection;\n"
"				gle_varying_directionalLightDirection[i].x = dot(tmp, t);\n"
"				gle_varying_directionalLightDirection[i].y = dot(tmp, b);\n"
"				gle_varying_directionalLightDirection[i].z = dot(tmp, n);	\n"
"			}\n"
"		else\n"
"			gle_varying_directionalLightDirection[i] = directionalLightDirection;\n"
"	}\n"
"	#endif\n"
"	#if GLE_NB_POINT_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_POINT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 pointLightDirection = gle_pointLightPosition[i] - gle_mvPosition.xyz;\n"
"			float d = length(pointLightDirection);\n"
"			if (gle_pointLightAttenuation[i].x == 0.0 && gle_pointLightAttenuation[i].y == 0.0 && gle_pointLightAttenuation[i].z == 0.0)\n"
"			   gle_varying_pointLightAttenuation[i] = 1.0;\n"
"			else\n"
"			   gle_varying_pointLightAttenuation[i] = 1.0 / (gle_pointLightAttenuation[i].x +\n"
"			   			      	 (gle_pointLightAttenuation[i].y * d) + \n"
"			     				 (gle_pointLightAttenuation[i].z * d * d));\n"
"			if (gle_varying_pointLightAttenuation[i] > 1.0)\n"
"				gle_varying_pointLightAttenuation[i] = 1.0;\n"
"			if (hasNormalMap > 0.0)\n"
"			{\n"
"				vec3 tmp = pointLightDirection;\n"
"				gle_varying_pointLightDirection[i].x = dot(tmp, t);\n"
"				gle_varying_pointLightDirection[i].y = dot(tmp, b);\n"
"				gle_varying_pointLightDirection[i].z = dot(tmp, n);\n"
"			}\n"
"			else\n"
"				gle_varying_pointLightDirection[i] = pointLightDirection;\n"
"		}\n"
"	#endif\n"
"	#if GLE_NB_SPOT_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_SPOT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 spotLightDirection = gle_spotLightPosition[i] - gle_mvPosition.xyz;\n"
"			float d = length(spotLightDirection);\n"
"			if (gle_spotLightAttenuation[i].x == 0.0 && gle_spotLightAttenuation[i].y == 0.0 && gle_spotLightAttenuation[i].z == 0.0)\n"
"			   gle_varying_spotLightAttenuation[i] = 1.0;\n"
"			else\n"
"			   gle_varying_spotLightAttenuation[i] = 1.0 / (gle_spotLightAttenuation[i].x +\n"
"			   			      	 					(gle_spotLightAttenuation[i].y * d) + \n"
"							 						(gle_spotLightAttenuation[i].z * d * d));\n"
"			if (gle_varying_spotLightAttenuation[i] > 1.0)\n"
"				gle_varying_spotLightAttenuation[i] = 1.0;\n"
"			if (hasNormalMap > 0.0)\n"
"			{\n"
"				vec3 tmp = spotLightDirection;\n"
"				gle_varying_spotLightDirection[i].x = dot(tmp, t);\n"
"				gle_varying_spotLightDirection[i].y = dot(tmp, b);\n"
"				gle_varying_spotLightDirection[i].z = dot(tmp, n);\n"
"			}\n"
"			else\n"
"				gle_varying_spotLightDirection[i] = spotLightDirection;\n"
"			gle_varying_spotLightRealDirection[i] = spotLightDirection;\n"
"		}\n"
"	#endif\n"
"	\n"
"	gle_varying_vLightWeighting += ambientColor.rgb;\n"
"\n"
"	if (reflectionIntensity > 0 && envMapType == GLE_CUBE_MAP)\n"
"	{	\n"
"		vec4 WorldPos = mwMatrix * vec4(gle_vPosition, 1.0);\n"
"		vec3 N = normalize(mat3(mwMatrix) * gle_vNormal);\n"
"		vec3 E = normalize(WorldPos.xyz - gle_CameraPos.xyz);\n"
"		gle_varying_envMapVector = reflect(E, N);\n"
"	}\n"
"}\n"
"\n"
;

const char* gle::ShaderSource::FragmentShader = 
"#version 330 core \n"
"  \n"
"#define GLE_OUT_FRAGMENT_COLOR_LOCATION 0 \n"
"#define GLE_NB_DIRECTIONAL_LIGHTS %nb_directional_lights \n"
"#define GLE_NB_POINT_LIGHTS %nb_point_lights  \n"
"#define GLE_NB_SPOT_LIGHTS %nb_spot_lights \n"
"#define GLE_NB_MATERIALS %nb_materials\n"
"\n"
"#define GLE_CUBE_MAP 1\n"
"  \n"
"layout (location = GLE_OUT_FRAGMENT_COLOR_LOCATION) out vec4 gle_FragColor; \n"
"\n"
"struct gle_MaterialStruct\n"
"{\n"
"	vec4 ambientColor;\n"
"	vec4 diffuseColor;\n"
"	vec4 specularColor;\n"
"	float shininess;\n"
"	float specularIntensity;\n"
"	float diffuseIntensity;\n"
"	float reflectionIntensity;\n"
"	float envMapType;\n"
"	float hasColorMap;\n"
"	float hasNormalMap;\n"
"};\n"
"\n"
"layout(std140) uniform materialBlock\n"
"{\n"
"	gle_MaterialStruct materials[GLE_NB_MATERIALS];\n"
"} gle_material;\n"
"\n"
"uniform mat4 gle_MVMatrix;\n"
"\n"
"uniform vec3 gle_fogColor;\n"
"\n"
"uniform sampler2D gle_colorMap;\n"
"uniform sampler2D gle_normalMap;\n"
"uniform samplerCube gle_cubeMap;\n"
"\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"	uniform vec3 gle_directionalLightColor[GLE_NB_DIRECTIONAL_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_POINT_LIGHTS > 0\n"
"	uniform vec3 gle_pointLightColor[GLE_NB_POINT_LIGHTS];\n"
"	uniform vec3 gle_pointLightSpecularColor[GLE_NB_POINT_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_SPOT_LIGHTS > 0\n"
"	uniform vec3 gle_spotLightColor[GLE_NB_SPOT_LIGHTS];\n"
"	uniform vec3 gle_spotLightSpecularColor[GLE_NB_SPOT_LIGHTS];\n"
"	uniform vec3 gle_spotLightDirection[GLE_NB_SPOT_LIGHTS];\n"
"	uniform float gle_spotLightCosCutOff[GLE_NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"in float gle_varying_fogFactor; \n"
"in vec3 gle_varying_vLightWeighting;\n"
"in float gle_varying_vLightAttenuation;\n"
"in vec2 gle_varying_vTextureCoord;\n"
"in vec3 gle_varying_envMapVector;\n"
"\n"
"flat in vec3 gle_varying_vMeshIdentifier;\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"	in vec3 gle_varying_normal;\n"
"	in vec3 gle_varying_eyeDirection;\n"
"#endif\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"	in vec3 gle_varying_directionalLightDirection[GLE_NB_DIRECTIONAL_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_POINT_LIGHTS > 0\n"
"	in vec3 gle_varying_pointLightDirection[GLE_NB_POINT_LIGHTS];\n"
"	in float gle_varying_pointLightAttenuation[GLE_NB_POINT_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_SPOT_LIGHTS > 0\n"
"	in vec3 gle_varying_spotLightDirection[GLE_NB_SPOT_LIGHTS];\n"
"	in vec3 gle_varying_spotLightRealDirection[GLE_NB_SPOT_LIGHTS];\n"
"	in float gle_varying_spotLightAttenuation[GLE_NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"void main(void) {\n"
"\n"
"	vec4 ambientColor = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].ambientColor;\n"
"	vec4 diffuseColor = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].diffuseColor;\n"
"	vec4 specularColor = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].specularColor;\n"
"	float shininess = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].shininess;\n"
"	float specularIntensity = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].specularIntensity;\n"
"	float diffuseIntensity = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].diffuseIntensity;\n"
"	float reflectionIntensity = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].reflectionIntensity;\n"
"	float envMapType = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].envMapType;\n"
"	float hasColorMap = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].hasColorMap;\n"
"	float hasNormalMap = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].hasNormalMap;\n"
"	\n"
"	vec3 lightWeighting = gle_varying_vLightWeighting;\n"
"	vec3 bump = vec3(0.0, 1.0, 0.0);\n"
"	#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"		vec3 N = normalize(gle_varying_normal);\n"
"		vec3 E = normalize(gle_varying_eyeDirection);\n"
"		if (hasNormalMap > 0.0)\n"
"		{\n"
"			vec2 tmp = vec2(gle_varying_vTextureCoord.x, -gle_varying_vTextureCoord.y);\n"
"			bump = normalize(texture2D(gle_normalMap, tmp).xyz * 2.0 - 1.0);\n"
"		}\n"
"	#endif\n"
"	#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_DIRECTIONAL_LIGHTS; ++i)\n"
"		{\n"
"			if (diffuseIntensity > 0)\n"
"			{\n"
"				float directionalLightWeighting = 0.0;\n"
"				if (hasNormalMap > 0.0)\n"
"					directionalLightWeighting = max(dot(bump,\n"
"													gle_varying_directionalLightDirection[i]), 0.0);\n"
"				else\n"
"					directionalLightWeighting = max(dot(N,\n"
"													gle_varying_directionalLightDirection[i]), 0.0);\n"
"				lightWeighting += gle_directionalLightColor[i] * diffuseColor.rgb * directionalLightWeighting * diffuseIntensity;\n"
"			}\n"
"			if (specularIntensity > 0)\n"
"			{\n"
"				float directionalLightWeighting = 0.0;\n"
"				if (hasNormalMap > 0.0)\n"
"					directionalLightWeighting = pow(max(dot(reflect(-gle_varying_directionalLightDirection[i], bump), E), 0.0), shininess);\n"
"				else\n"
"					directionalLightWeighting = pow(max(dot(reflect(-gle_varying_directionalLightDirection[i], N), E), 0.0), shininess);\n"
"				lightWeighting += gle_directionalLightColor[i] * specularColor.rgb\n"
"							* directionalLightWeighting * specularIntensity;\n"
"			}\n"
"		}\n"
"	#endif\n"
"	#if GLE_NB_POINT_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_POINT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 L = normalize(gle_varying_pointLightDirection[i]);\n"
"\n"
"			if (diffuseIntensity > 0)\n"
"			{\n"
"				float pointLightWeighting = 0.0;\n"
"				if (hasNormalMap > 0.0)\n"
"					pointLightWeighting = max(dot(L, bump), 0.0);\n"
"				else\n"
"					pointLightWeighting = max(dot(L, N), 0.0);\n"
"				lightWeighting += gle_pointLightColor[i] * diffuseColor.rgb * pointLightWeighting * diffuseIntensity * \n"
"				gle_varying_pointLightAttenuation[i];\n"
"			}\n"
"			if (specularIntensity > 0)\n"
"			{\n"
"				float pointLightSpecularWeighting = 0.0;\n"
"				if (hasNormalMap > 0.0)\n"
"					pointLightSpecularWeighting = pow(clamp(dot(reflect(-L, bump), E), 0.0, 1.0), shininess);\n"
"				else\n"
"					pointLightSpecularWeighting = pow(max(dot(reflect(-L, N), E), 0.0), shininess);\n"
"				lightWeighting += gle_pointLightSpecularColor[i] * specularColor.rgb\n"
"							* pointLightSpecularWeighting * specularIntensity * gle_varying_pointLightAttenuation[i];\n"
"			}\n"
"		}\n"
"	#endif\n"
"	#if GLE_NB_SPOT_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_SPOT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 L = normalize(gle_varying_spotLightDirection[i]);\n"
"			vec3 D = normalize(gle_spotLightDirection[i]);\n"
"\n"
"			// COMPUTE SPOT ANGLE\n"
"			float cos_cur_angle = dot(-normalize(gle_varying_spotLightRealDirection[i]), D);\n"
"\n"
"			float cos_inner_cone_angle = gle_spotLightCosCutOff[i];\n"
"			float cos_outer_cone_angle = cos_inner_cone_angle * 0.95;\n"
"\n"
"			float cos_inner_minus_outer_angle = \n"
"				cos_inner_cone_angle - cos_outer_cone_angle;\n"
"\n"
"			float spot = clamp((cos_cur_angle - cos_outer_cone_angle) / \n"
"					cos_inner_minus_outer_angle, 0.0, 1.0);\n"
"\n"
"			if (diffuseIntensity > 0)\n"
"			{\n"
"				float spotLightWeighting = 0.0;\n"
"				if (hasNormalMap > 0.0)\n"
"					spotLightWeighting = max(dot(bump, L), 0.0);\n"
"				else\n"
"					spotLightWeighting = max(dot(N, L), 0.0);\n"
"				lightWeighting += gle_spotLightColor[i] * diffuseColor.rgb * spotLightWeighting * diffuseIntensity * \n"
"				gle_varying_spotLightAttenuation[i] * (spot);\n"
"			}\n"
"			if (specularIntensity > 0)\n"
"			{\n"
"				vec3 reflectionDirection = vec3(0.0, 0.0, 0.0);\n"
"				if (hasNormalMap > 0.0)\n"
"					reflectionDirection = reflect(-L, bump);\n"
"				else\n"
"					reflectionDirection = reflect(-L, N);\n"
"				float spotLightSpecularWeighting = pow(max(dot(reflectionDirection, E), 0.0), shininess);\n"
"				lightWeighting += gle_spotLightSpecularColor[i] * specularColor.rgb\n"
"							* spotLightSpecularWeighting * specularIntensity * gle_varying_spotLightAttenuation[i] * spot;\n"
"			}\n"
"		}\n"
"	#endif\n"
"	vec2 tmp = vec2(gle_varying_vTextureCoord.x, -gle_varying_vTextureCoord.y);\n"
"	if (hasColorMap > 0.0)\n"
"		gle_FragColor = texture2D(gle_colorMap, tmp) * vec4(lightWeighting, 1.0);\n"
"	else\n"
"		gle_FragColor = vec4(lightWeighting, 1.0);\n"
"	if (reflectionIntensity > 0 && envMapType == GLE_CUBE_MAP)\n"
"	{\n"
"		vec3 cube_color = texture(gle_cubeMap, gle_varying_envMapVector).rgb;\n"
"		gle_FragColor = vec4(mix(vec3(gle_FragColor), cube_color, reflectionIntensity), 1.0);\n"
"	}\n"
"	gle_FragColor = mix(vec4(gle_fogColor, 1.0), gle_FragColor, gle_varying_fogFactor)	;\n"
"}\n"
"\n"
;

