\documentclass [a4 paper,11pt]{article}
\usepackage [english]{babel}
\usepackage [utf8]{inputenc}
\usepackage [T1]{fontenc}
\usepackage{textcomp}
\usepackage{vmargin}
\setmarginsrb{2.5cm}{0.5cm}{2.5cm}{1,5cm}{1,5cm}{0.5cm}{1.0cm}{2.0cm}


\title {glEngine : Technical Specifications}
\author {GaÃ«l Jochaud du Plessix\\
Loick Michard}
\date {2012}

\begin{document}
\maketitle

\newpage

\tableofcontents

\newpage

\part{Introduction}
This document describes the technical specifications for the glEngine project. It comes with the Specifications document that explain the functional specifications. The technical specifications document describes the retained solutions for the glEngine project. These specifications are divided in two parts: the description of the scene management and how the 3D rendering work.

\part{Scene management}
In order to render a virtual world in 3D, the engine must manage a lot of data describing a scene. This part of the specifications describes the different elements that can be part of a scene and how they are arranged hierarchically by the engine.

\section{Scene elements}
A scene is composed of various kinds of elements that describe all the aspects of the virtual world to render.

\subsection{Materials}
Materials allow to specify how an object visually appear when rendered. It contains the following information:
\begin{itemize}
\item Ambient color
\item Diffuse color
\item Diffuse intensity
\item Specular color
\item Specular intensity
\item Shininess
\item Color map (texture)
\end{itemize}
A material also have a name, in order to identify it.\\
All these information are stored in a uniform buffer, in order to be efficiently used by the GPU.

\subsubsection{Creation}
The engine allows the creation of materials programmatically via the gle::Material class. All the properties of a material can be accessed and set via accessors.
\subsubsection{Import}
Materials can be imported from .mtl files through the .obj importer (Cf. section 1.2.2).

\subsection{Models}
Models are the virtual representation of 3D objects. They are characterized by:
\begin{itemize}
\item A geometry
\item A position
\item A rotation matrix
\item A scale matrix
\end{itemize}
Models must also have a material (Cf. Section 1.1) that describes how they appear.\\

\subsubsection{Creation}
The user can create a model programmatically. Thus, glEngine provides the gle::Mesh class.\\
Position, rotation and scale can be accessed via simple functions.\\
To specify the mesh geometry, there are several accessors that store their data directly on the hardware through the OpenGL APIs:
\begin{itemize}
\item gle::Mesh::setVertexes
\item gle::Mesh::setNormals
\item gle::Mesh::setTextureCoords
\item gle::Mesh::setIndexes
\end{itemize}
All these data can be provided in two ways: simple (GLfloat|GLuint)* buffers or gle::Array<(GLfloat|GLuint)> arrays.

\subsubsection{Import}
The engine allows the import of a mesh from a Wavefront OBJ file, thanks to the gle::ObjLoader class. Its function gle::ObjLoader::load returns a mesh imported from a .obj file. If the file includes .mtl files describing the model materials, they will also be imported (Cf. Section 1.1).
\subsubsection{Update}
Models can be updated at any time. To set new values on a gle::Mesh, the user can use the corresponding accessors functions.

\subsection{Lights}
Lights describe how a scene is illuminated. There are two types of lights: Directional an Point lights.\\
Point lights are characterized by a position, a diffuse color and a specular color. Directional lights have a direction vector and a diffuse color.
\subsubsection{Creation}
Lights can be created programmatically by the user through the classes gle::DirectionalLight and gle::PointLight, specifying all their properties manually.
\subsubsection{Update}
It is possible to update the properties of the lights at any time. Once the properties of a light has changed, the user must call gle::Scene::updateLights on the scene to update the lights meta-data.

\subsection{Cameras}
Cameras permit to specify the point of view of the observer in a scene. They have several properties common to other scene elements such as a position and an orientation (specified by a target). A camera also have specific information: a field o view, an aspect and the distances to near and far plane.
\subsubsection{Creation}
Cameras are created programmatically by the user via the class gle::PerspectiveCamera, specifying all properties at object construction.
\subsubsection{Update}
It is possible to update the properties of a camera at any time, through accessors methods provided by gle::Camera.

\section{Structural information}
Scene elements are structured hierarchically and have particular meta-data in order to improve the rendering process.\\
These data include information about whether the element is static or dynamic, its position in the scene graph and a representation of the world based on spatial partitioning.

\subsection{Elements hierarchy}
Each element of the scene must is represented as the node of a graph, in order to hierarchy them. Thus, each element have a parent and a list of child elements.\\
In addition, it is possible to name the elements and retrieve them easily within the scene graph, thanks to the functions gle::Mesh::getChildren and gle::Mesh::getChildrenByName.

\subsection{Static vs Dynamic}
In the scene, there are two main types of elements: static ones and dynamic ones.\\
As their name suggest, static elements are not subject to change with time. Thereby, the renderer can improve its performance when processing these elements.\\
Dynamic elements may rather be updated very often, so the engine provides ability to efficiently update the data of these elements, through the mesh accessors functions.

\subsection{Spatial partitioning}
In order to improve the rendering performance, the scene have a representation of its elements based on spatial partitioning. Thanks to that representation, the engine is able to efficiently treat a lot of elements.\\
This partitioning is made with an Octree. Each mesh has an associated bounding volume computed from its shape. Thanks to that, the partitioning tree can be made efficiently. 

\part{3D Rendering}
This part of the technical specifications describes the how the different features for 3D rendering work.\\
It lists the basic and advanced features of the renderer and describes the techniques retained for performance improvements.

\section{Basic features}
This section describes the main features that are supported by the glEngine renderer.

\subsection{Rasterisation}
The renderer is able to rasterize triangles processed from the scene graph, using the OpenGL 4.2 API.
\subsection{Textures}
Triangles rasterized by the renderer can be textured. It is possible to configure the quality of the textures and how they are rendered.

\section{Advanced features}
Some visual effects are added to the renderer in order to improve the realism of the rendered image.\\
These advanced features are be:
\begin{itemize}
\item Diffuse shading
\item Phong shading
\end{itemize}

\section{Performance}
In order to provide an efficient rendering process, some techniques are used by the glEngine to improve its performance capabilities.

\subsection{Metadatas processing}
The engine is able to process the scene meta-data in order to improve the rendering performance. Furthermore, it is able to perform a frustum culling.

\subsection{OpenGL 4.2}
Since this is the main purpose of this project, the glEngine takes advantage of the features of OpenGL 4.2 APIs to improve the rendering performance.\\
Thus, it uses Uniform Block Arrays to pack together all the mesh uniforms and reduce the number of draw calls.

\end{document}
