/**************************************/
/*        Shaders sources file        */
/* Generated with genShaderSource.php */
/**************************************/

#include <gle/opengl.h>
#include <ShaderSource.hpp>

const char* gle::ShaderSource::VertexShader = 
"#version 330 core \n"
"\n"
"#define GLE_IN_VERTEX_POSITION_LOCATION 0\n"
"#define GLE_IN_VERTEX_NORMAL_LOCATION 1\n"
"#define GLE_IN_VERTEX_TEXTURE_COORD_LOCATION 2\n"
"#define GLE_IN_VERTEX_MESH_ID_LOCATION 3\n"
"\n"
"#define GLE_LIGHT_ENABLED 1\n"
"#define GLE_NB_DIRECTIONAL_LIGHTS %nb_directional_lights \n"
"#define GLE_NB_POINT_LIGHTS %nb_point_lights\n"
"#define GLE_NB_SPOT_LIGHTS %nb_spot_lights\n"
"\n"
"#define GLE_NB_STATIC_MESHES %nb_static_meshes\n"
"#define GLE_NB_MATERIALS %nb_materials\n"
"\n"
"uniform mat4 gle_CameraMatrix;\n"
"uniform mat4 gle_PMatrix;\n"
"uniform float gle_fogDensity;\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"	uniform vec3 gle_directionalLightDirection[GLE_NB_DIRECTIONAL_LIGHTS];\n"
"	uniform vec3 gle_directionalLightColor[GLE_NB_DIRECTIONAL_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_POINT_LIGHTS > 0\n"
"	uniform vec3 gle_pointLightPosition[GLE_NB_POINT_LIGHTS];\n"
"	uniform vec3 gle_pointLightAttenuation[GLE_NB_POINT_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_SPOT_LIGHTS > 0\n"
"	uniform vec3 gle_spotLightPosition[GLE_NB_SPOT_LIGHTS];\n"
"	uniform vec3 gle_spotLightAttenuation[GLE_NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"#if GLE_NB_STATIC_MESHES > 0\n"
"layout(std140) uniform staticMeshesBlock\n"
"{\n"
"	uniform mat4 MVMatrix[GLE_NB_STATIC_MESHES];\n"
"} gle_staticMeshes;\n"
"#endif\n"
"\n"
"uniform mat4 gle_MVMatrix;\n"
"#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"	//uniform mat3 gle_NMatrix;\n"
"#endif\n"
"\n"
"struct gle_MaterialStruct\n"
"{\n"
"	vec4 ambientColor;\n"
"	vec4 diffuseColor;\n"
"	vec4 specularColor;\n"
"	float shininess;\n"
"	float specularIntensity;\n"
"	float diffuseIntensity;\n"
"};\n"
"\n"
"layout(std140) uniform materialBlock\n"
"{\n"
"/*\n"
"	vec4 ambientColor;\n"
"	vec4 diffuseColor;\n"
"	vec4 specularColor;\n"
"	float shininess;\n"
"	float specularIntensity;\n"
"	float diffuseIntensity;\n"
"*/\n"
"	gle_MaterialStruct materials[GLE_NB_MATERIALS];\n"
"} gle_material;\n"
"\n"
"layout (location = GLE_IN_VERTEX_POSITION_LOCATION) in vec3 gle_vPosition; \n"
"layout (location = GLE_IN_VERTEX_NORMAL_LOCATION) in vec3 gle_vNormal; \n"
"layout (location = GLE_IN_VERTEX_TEXTURE_COORD_LOCATION) in vec2 gle_vTextureCoord;\n"
"layout (location = GLE_IN_VERTEX_MESH_ID_LOCATION) in vec3 gle_vMeshIdentifier;\n"
"\n"
"out float gle_varying_fogFactor; \n"
"out vec3 gle_varying_vLightWeighting; \n"
"out vec2 gle_varying_vTextureCoord;\n"
"flat out vec3 gle_varying_vMeshIdentifier;\n"
"\n"
"#if GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"	out vec3 gle_varying_normal;\n"
"	out vec3 gle_varying_eyeDirection;\n"
"#endif\n"
"#if GLE_NB_POINT_LIGHTS > 0\n"
"	out vec3 gle_varying_pointLightDirection[GLE_NB_POINT_LIGHTS];\n"
"	out float gle_varying_pointLightAttenuation[GLE_NB_POINT_LIGHTS];\n"
"#endif\n"
"#if GLE_NB_SPOT_LIGHTS > 0\n"
"	out vec3 gle_varying_spotLightDirection[GLE_NB_SPOT_LIGHTS];\n"
"	out float gle_varying_spotLightAttenuation[GLE_NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"void main(void) {\n"
"\n"
"	vec4 ambientColor = gle_material.materials[int(gle_vMeshIdentifier.z)].ambientColor;\n"
"	vec4 diffuseColor = gle_material.materials[int(gle_vMeshIdentifier.z)].diffuseColor;\n"
"	vec4 specularColor = gle_material.materials[int(gle_vMeshIdentifier.z)].specularColor;\n"
"	float shininess = gle_material.materials[int(gle_vMeshIdentifier.z)].shininess;\n"
"	float specularIntensity = gle_material.materials[int(gle_vMeshIdentifier.z)].specularIntensity;\n"
"	float diffuseIntensity = gle_material.materials[int(gle_vMeshIdentifier.z)].diffuseIntensity;\n"
"	\n"
"	gle_varying_vMeshIdentifier = gle_vMeshIdentifier;\n"
"\n"
"	mat4 mvMatrix;\n"
"#if GLE_NB_STATIC_MESHES > 0\n"
"	if (!bool(gle_vMeshIdentifier.x))\n"
"		mvMatrix = gle_CameraMatrix * gle_staticMeshes.MVMatrix[int(gle_vMeshIdentifier.y)];\n"
"	else\n"
"#endif\n"
"		mvMatrix = gle_CameraMatrix * gle_MVMatrix;\n"
"	vec4 gle_mvPosition = mvMatrix * vec4(gle_vPosition, 1);\n"
"	mat3 nMatrix = transpose(mat3(inverse(mvMatrix)));\n"
"	gl_Position = gle_PMatrix * gle_mvPosition; \n"
"	float fogDistance = length(gle_mvPosition); \n"
"	const float LOG2 = 1.442695; \n"
"	gle_varying_fogFactor = exp2(-gle_fogDensity * gle_fogDensity * fogDistance * fogDistance * LOG2); \n"
"	gle_varying_fogFactor = clamp(gle_varying_fogFactor, 0.0, 1.0); \n"
"	#if GLE_NB_DIRECTIONAL_LIGHTS > 0 || GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"		vec3 transformedNormal = normalize(nMatrix * gle_vNormal);\n"
"	#endif\n"
"	gle_varying_vTextureCoord = gle_vTextureCoord; \n"
"\n"
"	gle_varying_vLightWeighting = vec3(0.0, 0.0, 0.0);\n"
"\n"
"	#if GLE_NB_DIRECTIONAL_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_DIRECTIONAL_LIGHTS; ++i)\n"
"		{\n"
"			float directionalLightWeighting = max(dot(transformedNormal, gle_directionalLightDirection[i]), 0.0);\n"
"			gle_varying_vLightWeighting += gle_directionalLightColor[i] * diffuseColor.rgb * directionalLightWeighting;\n"
"		}\n"
"	#endif\n"
"	#if GLE_NB_POINT_LIGHTS > 0 || GLE_NB_SPOT_LIGHTS > 0\n"
"		gle_varying_normal = nMatrix * gle_vNormal;\n"
"		gle_varying_eyeDirection = -gle_mvPosition.xyz;\n"
"	#endif\n"
"	#if GLE_NB_POINT_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_POINT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 pointLightDirection = gle_pointLightPosition[i] - gle_mvPosition.xyz;\n"
"			float d = length(pointLightDirection);\n"
"			if (gle_pointLightAttenuation[i].x == 0.0 && gle_pointLightAttenuation[i].y == 0.0 && gle_pointLightAttenuation[i].z == 0.0)\n"
"			   gle_varying_pointLightAttenuation[i] = 1.0;\n"
"			else\n"
"			   gle_varying_pointLightAttenuation[i] = 1.0 / (gle_pointLightAttenuation[i].x +\n"
"			   			      	 (gle_pointLightAttenuation[i].y * d) + \n"
"							 (gle_pointLightAttenuation[i].z * d * d));\n"
"			if (gle_varying_pointLightAttenuation[i] > 1.0)\n"
"				gle_varying_pointLightAttenuation[i] = 1.0;\n"
"			gle_varying_pointLightDirection[i] = pointLightDirection;\n"
"		}\n"
"	#endif\n"
"	#if GLE_NB_SPOT_LIGHTS > 0\n"
"		for (int i = 0; i < GLE_NB_SPOT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 spotLightDirection = gle_spotLightPosition[i] - gle_mvPosition.xyz;\n"
"			float d = length(spotLightDirection);\n"
"			if (gle_spotLightAttenuation[i].x == 0.0 && gle_spotLightAttenuation[i].y == 0.0 && gle_spotLightAttenuation[i].z == 0.0)\n"
"			   gle_varying_spotLightAttenuation[i] = 1.0;\n"
"			else\n"
"			   gle_varying_spotLightAttenuation[i] = 1.0 / (gle_spotLightAttenuation[i].x +\n"
"			   			      	 					(gle_spotLightAttenuation[i].y * d) + \n"
"							 						(gle_spotLightAttenuation[i].z * d * d));\n"
"			if (gle_varying_spotLightAttenuation[i] > 1.0)\n"
"				gle_varying_spotLightAttenuation[i] = 1.0;\n"
"			gle_varying_spotLightDirection[i] = spotLightDirection;\n"
"		}\n"
"	#endif\n"
"	\n"
"	gle_varying_vLightWeighting += ambientColor.rgb;\n"
"}\n"
"\n"
;

const char* gle::ShaderSource::FragmentShader = 
"#version 330 core \n"
"  \n"
"#define GLE_OUT_FRAGMENT_COLOR_LOCATION 0 \n"
"#define NB_POINT_LIGHTS %nb_point_lights  \n"
"#define NB_SPOT_LIGHTS %nb_spot_lights\n"
"\n"
"#define GLE_NB_MATERIALS %nb_materials\n"
"\n"
"layout (location = GLE_OUT_FRAGMENT_COLOR_LOCATION) out vec4 gle_FragColor;\n"
"\n"
"struct gle_MaterialStruct\n"
"{\n"
"	vec4 ambientColor;\n"
"	vec4 diffuseColor;\n"
"	vec4 specularColor;\n"
"	float shininess;\n"
"	float specularIntensity;\n"
"	float diffuseIntensity;\n"
"};\n"
"\n"
"layout(std140) uniform materialBlock\n"
"{\n"
"/*\n"
"	vec4 ambientColor;\n"
"	vec4 diffuseColor;\n"
"	vec4 specularColor;\n"
"	float shininess;\n"
"	float specularIntensity;\n"
"	float diffuseIntensity;\n"
"*/\n"
"	gle_MaterialStruct materials[GLE_NB_MATERIALS];\n"
"} gle_material;\n"
"\n"
"uniform mat4 gle_MVMatrix; \n"
"\n"
"uniform vec3 gle_fogColor;\n"
"\n"
"uniform sampler2D gle_colorMap;\n"
"uniform bool gle_hasColorMap;\n"
"\n"
"#if NB_POINT_LIGHTS > 0\n"
"	uniform vec3 gle_pointLightColor[NB_POINT_LIGHTS];\n"
"	uniform vec3 gle_pointLightSpecularColor[NB_POINT_LIGHTS];\n"
"#endif\n"
"#if NB_SPOT_LIGHTS > 0\n"
"	uniform vec3 gle_spotLightColor[NB_SPOT_LIGHTS];\n"
"	uniform vec3 gle_spotLightSpecularColor[NB_SPOT_LIGHTS];\n"
"	uniform vec3 gle_spotLightDirection[NB_SPOT_LIGHTS];\n"
"	uniform float gle_spotLightCosCutOff[NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"in float gle_varying_fogFactor; \n"
"in vec3 gle_varying_vLightWeighting;\n"
"in float gle_varying_vLightAttenuation;\n"
"in vec2 gle_varying_vTextureCoord;\n"
"flat in vec3 gle_varying_vMeshIdentifier;\n"
"\n"
"#if NB_POINT_LIGHTS > 0 || NB_SPOT_LIGHTS > 0\n"
"	in vec3 gle_varying_normal;\n"
"	in vec3 gle_varying_eyeDirection;\n"
"#endif\n"
"#if NB_POINT_LIGHTS > 0\n"
"	in vec3 gle_varying_pointLightDirection[NB_POINT_LIGHTS];\n"
"	in float gle_varying_pointLightAttenuation[NB_POINT_LIGHTS];\n"
"#endif\n"
"#if NB_SPOT_LIGHTS > 0\n"
"	in vec3 gle_varying_spotLightDirection[NB_SPOT_LIGHTS];\n"
"	in float gle_varying_spotLightAttenuation[NB_SPOT_LIGHTS];\n"
"#endif\n"
"\n"
"void main(void) {\n"
"\n"
"	vec4 ambientColor = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].ambientColor;\n"
"	vec4 diffuseColor = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].diffuseColor;\n"
"	vec4 specularColor = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].specularColor;\n"
"	float shininess = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].shininess;\n"
"	float specularIntensity = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].specularIntensity;\n"
"	float diffuseIntensity = gle_material.materials[int(gle_varying_vMeshIdentifier.z)].diffuseIntensity;\n"
"	\n"
"	vec3 lightWeighting = gle_varying_vLightWeighting;\n"
"	#if NB_POINT_LIGHTS > 0 || NB_SPOT_LIGHTS > 0\n"
"		vec3 N = normalize(gle_varying_normal);\n"
"		vec3 E = normalize(gle_varying_eyeDirection);\n"
"	#endif\n"
"	#if NB_POINT_LIGHTS > 0\n"
"		for (int i = 0; i < NB_POINT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 L = normalize(gle_varying_pointLightDirection[i]);\n"
"\n"
"			if (diffuseIntensity > 0)\n"
"			{\n"
"				float pointLightWeighting = max(dot(N, L), 0.0);\n"
"				lightWeighting += gle_pointLightColor[i] * diffuseColor.rgb * pointLightWeighting * diffuseIntensity * \n"
"				gle_varying_pointLightAttenuation[i];\n"
"			}\n"
"			if (specularIntensity > 0)\n"
"			{\n"
"				vec3 reflectionDirection = reflect(-L, N);\n"
"				float pointLightSpecularWeighting = pow(max(dot(reflectionDirection, E), 0.0), shininess);\n"
"				lightWeighting += gle_pointLightSpecularColor[i] * specularColor.rgb\n"
"							* pointLightSpecularWeighting * specularIntensity * gle_varying_pointLightAttenuation[i];\n"
"			}\n"
"		}\n"
"	#endif\n"
"	#if NB_SPOT_LIGHTS > 0\n"
"		for (int i = 0; i < NB_SPOT_LIGHTS; ++i)\n"
"		{\n"
"			vec3 L = normalize(gle_varying_spotLightDirection[i]);\n"
"			vec3 D = normalize(gle_spotLightDirection[i]);\n"
"\n"
"			// COMPUTE SPOT ANGLE\n"
"			float cos_cur_angle = dot(-L, D);\n"
"\n"
"			float cos_inner_cone_angle = gle_spotLightCosCutOff[i];\n"
"			float cos_outer_cone_angle = cos_inner_cone_angle * 0.95;\n"
"\n"
"			float cos_inner_minus_outer_angle = \n"
"				cos_inner_cone_angle - cos_outer_cone_angle;\n"
"\n"
"			float spot = clamp((cos_cur_angle - cos_outer_cone_angle) / \n"
"					cos_inner_minus_outer_angle, 0.0, 1.0);\n"
"\n"
"			if (diffuseIntensity > 0)\n"
"			{\n"
"				float spotLightWeighting = max(dot(N, L), 0.0);\n"
"				lightWeighting += gle_spotLightColor[i] * diffuseColor.rgb * spotLightWeighting * diffuseIntensity * \n"
"				gle_varying_spotLightAttenuation[i] * (spot);\n"
"			}\n"
"			if (specularIntensity > 0)\n"
"			{\n"
"				vec3 reflectionDirection = reflect(-L, N);\n"
"				float spotLightSpecularWeighting = pow(max(dot(reflectionDirection, E), 0.0), shininess);\n"
"				lightWeighting += gle_spotLightSpecularColor[i] * specularColor.rgb\n"
"							* spotLightSpecularWeighting * specularIntensity * gle_varying_spotLightAttenuation[i] * spot;\n"
"			}\n"
"		}\n"
"	#endif\n"
"\n"
"	vec2 tmp = vec2(gle_varying_vTextureCoord.x, -gle_varying_vTextureCoord.y);\n"
"	if (gle_hasColorMap)\n"
"	{\n"
"		gle_FragColor = texture2D(gle_colorMap, tmp) * vec4(lightWeighting, 1.0);\n"
"	}\n"
"	else\n"
"	{\n"
"		gle_FragColor = vec4(lightWeighting, 1.0);\n"
"	}\n"
"	gle_FragColor = mix(vec4(gle_fogColor, 1.0), gle_FragColor, gle_varying_fogFactor);\n"
"}\n"
"\n"
;

